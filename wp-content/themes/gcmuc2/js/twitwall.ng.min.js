/*!
 * angular-masonry <%= pkg.version %>
 * Pascal Hartig, weluse GmbH, http://weluse.de/
 * License: MIT
 */
(function () {
  'use strict';

  angular.module('wu.masonry', [])
    .controller('MasonryCtrl', function controller($scope, $element, $timeout) {
      var bricks = {};
      var schedule = [];
      var destroyed = false;
      var self = this;
      var timeout = null;

      this.preserveOrder = false;
      this.loadImages = true;

      this.scheduleMasonryOnce = function scheduleMasonryOnce() {
        var args = arguments;
        var found = schedule.filter(function filterFn(item) {
          return item[0] === args[0];
        }).length > 0;

        if (!found) {
          this.scheduleMasonry.apply(null, arguments);
        }
      };

      // Make sure it's only executed once within a reasonable time-frame in
      // case multiple elements are removed or added at once.
      this.scheduleMasonry = function scheduleMasonry() {
        if (timeout) {
          $timeout.cancel(timeout);
        }

        schedule.push([].slice.call(arguments));

        timeout = $timeout(function runMasonry() {
          if (destroyed) {
            return;
          }
          schedule.forEach(function scheduleForEach(args) {
            $element.masonry.apply($element, args);
          });
          schedule = [];
        }, 30);
      };

      function defaultLoaded($element) {
        $element.addClass('loaded');
      }

      this.appendBrick = function appendBrick(element, id) {
        if (destroyed) {
          return;
        }

        function _append() {
          if (Object.keys(bricks).length === 0) {
            $element.masonry('resize');
          }
          if (bricks[id] === undefined) {
            // Keep track of added elements.
            bricks[id] = true;
            defaultLoaded(element);
            $element.masonry('appended', element, true);
          }
        }

        function _layout() {
          // I wanted to make this dynamic but ran into huuuge memory leaks
          // that I couldn't fix. If you know how to dynamically add a
          // callback so one could say <masonry loaded="callback($element)">
          // please submit a pull request!
          self.scheduleMasonryOnce('layout');
        }

        if (!self.loadImages){
          _append();
          _layout();
        } else if (self.preserveOrder) {
          _append();
          element.imagesLoaded(_layout);
        } else {
          element.imagesLoaded(function imagesLoaded() {
            _append();
            _layout();
          });
        }
      };

      this.removeBrick = function removeBrick(id, element) {
        if (destroyed) {
          return;
        }

        delete bricks[id];
        $element.masonry('remove', element);
        this.scheduleMasonryOnce('layout');
      };

      this.destroy = function destroy() {
        destroyed = true;

        if ($element.data('masonry')) {
          // Gently uninitialize if still present
          $element.masonry('destroy');
        }
        $scope.$emit('masonry.destroyed');

        bricks = [];
      };

      this.reload = function reload() {
        $element.masonry();
        $scope.$emit('masonry.reloaded');
      };


    }).directive('masonry', function masonryDirective() {
      return {
        restrict: 'AE',
        controller: 'MasonryCtrl',
        link: {
          pre: function preLink(scope, element, attrs, ctrl) {
            var attrOptions = scope.$eval(attrs.masonry || attrs.masonryOptions);
            var options = angular.extend({
              itemSelector: attrs.itemSelector || '.masonry-brick',
              columnWidth: parseInt(attrs.columnWidth, 10) || attrs.columnWidth
            }, attrOptions || {});
            element.masonry(options);
            var loadImages = scope.$eval(attrs.loadImages);
            ctrl.loadImages = loadImages !== false;
            var preserveOrder = scope.$eval(attrs.preserveOrder);
            ctrl.preserveOrder = (preserveOrder !== false && attrs.preserveOrder !== undefined);

            scope.$emit('masonry.created', element);
            scope.$on('$destroy', ctrl.destroy);
          }
        }
      };
    }).directive('masonryBrick', function masonryBrickDirective() {
      return {
        restrict: 'AC',
        require: '^masonry',
        scope: true,
        link: {
          pre: function preLink(scope, element, attrs, ctrl) {
            var id = scope.$id, index;

            ctrl.appendBrick(element, id);
            element.on('$destroy', function () {
              ctrl.removeBrick(id, element);
            });

            scope.$on('masonry.reload', function () {
              ctrl.scheduleMasonryOnce('reloadItems');
              ctrl.scheduleMasonryOnce('layout');
            });

            scope.$watch('$index', function () {
              if (index !== undefined && index !== scope.$index) {
                ctrl.scheduleMasonryOnce('reloadItems');
                ctrl.scheduleMasonryOnce('layout');
              }
              index = scope.$index;
            });
          }
        }
      };
    });
}());

/* **********************************************
     Begin ng.relative-date.js
********************************************** */

(function() {
  angular.module('relativeDate', []).value('now', new Date()).filter('relativeDate', [
    'now', function(now) {
      return function(date) {
        var calculateDelta, day, delta, hour, minute, month, week, year;
        if (!(date instanceof Date)) {
          date = new Date(date);
        }
        delta = null;
        minute = 60;
        hour = minute * 60;
        day = hour * 24;
        week = day * 7;
        month = day * 30;
        year = day * 365;
        calculateDelta = function() {
          return delta = Math.round((now - date) / 1000);
        };
        calculateDelta();
        if (delta > day && delta < week) {
          date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
          calculateDelta();
        }
        switch (false) {
          case !(delta < 30):
            return 'gerade eben';
          case !(delta < minute):
            return 'vor ' + delta + " Sekunden";
          case !(delta < 2 * minute):
            return 'vor einer Minute';
          case !(delta < hour):
            return "vor " + (Math.floor(delta / minute)) + " Minuten";
          case Math.floor(delta / hour) !== 1:
            return 'vor einer Stunde';
          case !(delta < day):
            return "vor " + (Math.floor(delta / hour)) + " Stunden";
          case !(delta < day * 2):
            return 'Gestern';
          case !(delta < week):
            return "vor " + (Math.floor(delta / day)) + " Tagen";
          case Math.floor(delta / week) !== 1:
            return 'a week ago';
          case !(delta < month):
            return "vor " + (Math.floor(delta / week)) + " Wochen";
          case Math.floor(delta / month) !== 1:
            return 'vor einem Monat';
          case !(delta < year):
            return "vor " + (Math.floor(delta / month)) + " Monaten";
          case Math.floor(delta / year) !== 1:
            return 'vor einem Jahr';
          default:
            return 'vor Ã¼ber einem Jahr';
        }
      };
    }
  ]);

}).call(this);


/* **********************************************
     Begin twitwall.ng.js
********************************************** */

var twitter_json_search = "twitter/gcmuc_search.php";
var flickr_json_search = "flickr/search.php";

var app = angular.module('socialwallApp', ['relativeDate']);
var searchterm = "%23gcmuc";


app.controller("appController", function($scope, $http){

});

app.controller("socalwallController", function($scope, $http){
	$scope.shownItems = [];
	$scope.socialContent = [];
	$scope.max_id_str = 0;

	$scope.init = function(){


		$scope.loadContent();
		$scope.runner = setInterval(function(){
			$scope.loadContent();
		}, 10000)
	}

	$scope.loadContent = function(){
		$scope.loadTwitter();
		$scope.loadFlickr();
	};

	// Load stuff from twitter
	$scope.loadTwitter = function(){

		var httpUrl = twitter_json_search + "?callback=JSON_CALLBACK";
		var config = {
			params: {
				q: searchterm,
			},
		};

		if($scope.shownItems.length > 0 && $scope.max_id_str != 0){
			config.params.since_id = $scope.max_id_str
		}

		$http.jsonp(httpUrl, config).success(function(data){
			$scope.max_id_str = data.search_metadata.max_id_str;

			for(i in data.statuses){
				var t = data.statuses[i];

				var tmp_image = null;

				if(typeof(t.entities.media) != "undefined"){
					tmp_image = t.entities.media[0].media_url;
				}

				$scope.addSocialContent({
					id: t.id_str,
					user_name: "@" + t.user.screen_name,
					display_name: t.user.name,
					user_image: t.user.profile_image_url,
					image: tmp_image,
					time: Date.parse(t.created_at),
					text: t.text,
					type: "twitter",
				})
			}
		});
	};

	// Load stuff from flickr
	$scope.loadFlickr = function(){

		var httpUrl = flickr_json_search + "?callback=JSON_CALLBACK";
		var config = {
			params: {
				q: searchterm.replace("%23", ""),
			},
		};

		$http.jsonp(httpUrl, config).success(function(data){
			for(i in data.photos.photo){
				var p = data.photos.photo[i];

				$scope.addSocialContent({
					id: p.id,
					user_name: null,
					display_name: p.ownername,
					user_image: null,
					image: p.url_l,
					time: p.dateupload*1000,
					text: null,
					type: "flickr",
				})
			}
		});
	};


	$scope.addSocialContent = function(obj){
		var item = {
			id: obj.id,
			user_name: obj.user_name,
			display_name: obj.display_name,
			user_image: obj.user_image,
			image: obj.image,
			time: obj.time,
			type: obj.type,
			text: obj.text,
		}

		if($scope.shownItems.indexOf(item.type+"_"+item.id) == -1){
			$scope.socialContent.unshift(item);
			$scope.shownItems.unshift(item.type+"_"+item.id);
		}
	};
});