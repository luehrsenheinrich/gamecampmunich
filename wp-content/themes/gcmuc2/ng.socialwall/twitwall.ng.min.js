(function() {
  angular.module('relativeDate', []).value('now', new Date()).filter('relativeDate', [
    'now', function(now) {
      return function(date) {
        var calculateDelta, day, delta, hour, minute, month, week, year;
        if (!(date instanceof Date)) {
          date = new Date(date);
        }
        delta = null;
        minute = 60;
        hour = minute * 60;
        day = hour * 24;
        week = day * 7;
        month = day * 30;
        year = day * 365;
        calculateDelta = function() {
          return delta = Math.round((now - date) / 1000);
        };
        calculateDelta();
        if (delta > day && delta < week) {
          date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
          calculateDelta();
        }
        switch (false) {
          case !(delta < 30):
            return 'gerade eben';
          case !(delta < minute):
            return 'vor ' + delta + " Sekunden";
          case !(delta < 2 * minute):
            return 'vor einer Minute';
          case !(delta < hour):
            return "vor " + (Math.floor(delta / minute)) + " Minuten";
          case Math.floor(delta / hour) !== 1:
            return 'vor einer Stunde';
          case !(delta < day):
            return "vor " + (Math.floor(delta / hour)) + " Stunden";
          case !(delta < day * 2):
            return 'Gestern';
          case !(delta < week):
            return "vor " + (Math.floor(delta / day)) + " Tagen";
          case Math.floor(delta / week) !== 1:
            return 'a week ago';
          case !(delta < month):
            return "vor " + (Math.floor(delta / week)) + " Wochen";
          case Math.floor(delta / month) !== 1:
            return 'vor einem Monat';
          case !(delta < year):
            return "vor " + (Math.floor(delta / month)) + " Monaten";
          case Math.floor(delta / year) !== 1:
            return 'vor einem Jahr';
          default:
            return 'vor Ã¼ber einem Jahr';
        }
      };
    }
  ]);

}).call(this);


/* **********************************************
     Begin ng.masonry.js
********************************************** */

(function() {
    "use strict";

    angular.module('masonry', ['ng']).directive('masonry', function($parse) {
        return {
            restrict: 'AC',
            link: function(scope, elem, attrs) {
                scope.items = [];
                var container = elem[0];
                var options = angular.extend({
                    itemSelector: '.item',
                }, JSON.parse(attrs.masonry));

                scope.obj = new Masonry(container, options);
            }
        };
    }).directive('masonryTile', function() {
        return {
            restrict: 'AC',
            link: function(scope, elem) {
                var master = elem.parent('*[masonry]:first').scope();
                var masonry = master.obj;

                elem.ready(function() {
                    masonry.addItems([elem]);
                    setTimeout(function(){
                    	masonry.reloadItems();
						masonry.layout();
					}, 0);
                });
            }
        };
    });
})();

/* **********************************************
     Begin ng.isotope.js
********************************************** */

(function(window, document) {

// Create all modules and define dependencies to make sure they exist
// and are loaded in the correct order to satisfy dependency injection
// before all nested files are concatenated by Grunt

// Config
angular.module('iso.config', [])
    .value('iso.config', {
        debug: true
    });

// Modules
angular.module('iso.directives', ['iso.services']);
angular.module('iso.services', []);
angular.module('iso',
    [
        'iso.config',
        'iso.directives',
        'iso.services'
    ]);


angular.module("iso.controllers", ["iso.config", "iso.services"])
.controller("angularIsotopeController", [
  "iso.config", "iso.topics", "$scope", "$timeout", "optionsStore", function(config, topics, $scope, $timeout, optionsStore) {
    "use strict";
    var buffer, initEventHandler, isoMode, isotopeContainer, methodHandler, onLayoutEvent, optionsHandler, postInitialized, scope;
    onLayoutEvent = "isotope.onLayout";
    postInitialized = false;
    isotopeContainer = null;
    buffer = [];
    scope = "";
    isoMode = "";
    $scope.$on(onLayoutEvent, function(event) {});
    $scope.layoutEventEmit = function($elems, instance) {
      return $timeout(function() {
        return $scope.$apply(function() {
          return $scope.$emit(onLayoutEvent);
        });
      });
    };
    optionsStore.store({
      onLayout: $scope.layoutEventEmit
    });
    initEventHandler = function(fun, evt, hnd) {
      if (evt) {
        return fun.call($scope, evt, hnd);
      }
    };
    $scope.init = function(isoInit) {
      isotopeContainer = isoInit.element;
      initEventHandler($scope.$on, isoInit.isoOptionsEvent || topics.MSG_OPT, optionsHandler);
      initEventHandler($scope.$on, isoInit.isoMethodEvent || topics.MSG_METH, methodHandler);
      $scope.isoMode = isoInit.isoMode || "addItems";
      return $timeout(function() {
        var opts = optionsStore.retrieve();
        isotopeContainer.isotope(opts);
        postInitialized = true;
      });
    };
    $scope.setIsoElement = function($element) {
      if (postInitialized) {
        return $timeout(function() {
          return isotopeContainer.isotope($scope.isoMode, $element);
        });
      }
    };
    $scope.refreshIso = function() {
      if (postInitialized) {
        return isotopeContainer.isotope();
      }
    };
    $scope.updateOptions = function(option) {
      if (isotopeContainer) {
        isotopeContainer.isotope(option);
      } else {
        optionsStore.store(option);
      }
    };
    optionsHandler = function(event, option) {
      return $scope.updateOptions(option);
    };
    methodHandler = function(event, option) {
      var fun, params;
      fun = option.fun;
      params = option.params;
      return fun.apply($scope, params);
    };

    $scope.removeAll = function(cb) {
      return isotopeContainer.isotope("remove", isotopeContainer.data("isotope").$allAtoms, cb);
    };
    $scope.refresh = function() {
      return isotopeContainer.isotope();
    };
    $scope.$on(config.refreshEvent, function() {
      return $scope.refreshIso();
    });
    $scope.$on(topics.MSG_REMOVE, function(message, element) {
      return $scope.removeElement(element);
    });
    $scope.removeElement = function(element) {
      return isotopeContainer.isotope("remove", element);
    };
  }
])
.controller("isoSortByDataController", [
  "iso.config", "$scope", "optionsStore", function(config, $scope, optionsStore) {
    var getValue, reduce;
    $scope.getHash = function(s) {
      return "opt" + s;
    };
    $scope.storeMethods = function(methods) {
      return optionsStore.store({
        getSortData: methods
      });
    };
    $scope.optSortData = function(item, index) {
      var $item, elementSortData, fun, genSortDataClosure, selector, sortKey, type;
      elementSortData = {};
      $item = $(item);
      selector = $item.attr("ok-sel");
      type = $item.attr("ok-type");
      sortKey = $scope.getHash(selector);
      fun = ($item.attr("opt-convert") ? eval_("[" + $item.attr("opt-convert") + "]")[0] : null);
      genSortDataClosure = function(selector, type, convert) {
        return function($elem) {
          return getValue(selector, $elem, type, convert);
        };
      };
      elementSortData[sortKey] = genSortDataClosure(selector, type, fun);
      return elementSortData;
    };
    $scope.createSortByDataMethods = function(elem) {
      var options, sortDataArray;
      options = $(elem);
      sortDataArray = reduce($.map(options, $scope.optSortData));
      return sortDataArray;
    };
    reduce = function(list) {
      var reduction;
      reduction = {};
      $.each(list, function(index, item) {
        return $.extend(reduction, item);
      });
      return reduction;
    };
    getValue = function(selector, $elem, type, evaluate) {
      var getText, item, text, toType, val;
      getText = function($elem, item, selector) {
        var text;
        if (!item.length) {
          return $elem.text();
        }
        text = "";
        switch (selector.charAt(0)) {
          case "#":
            text = item.text();
            break;
          case ".":
            text = item.text();
            break;
          case "[":
            text = item.attr(selector.replace("[", "").replace("]", "").split()[0]);
        }
        return text;
      };
      toType = function(text, type) {
        var numCheck, utility;
        numCheck = function(val) {
          if (isNaN(val)) {
            return Number.POSITIVE_INFINITY;
          } else {
            return val;
          }
        };
        utility = {
          text: function(s) {
            return s.toString();
          },
          integer: function(s) {
            return numCheck(parseInt(s, 10));
          },
          float: function(s) {
            return numCheck(parseFloat(s));
          },
          boolean: function(s) {
            return "true" === s;
          }
        };
        if (utility[type]) {
          return utility[type](text);
        } else {
          return text;
        }
      };
      item = $elem.find(selector);
      text = getText($elem, item, selector);
      val = toType(text, type);
      if (evaluate) {
        return evaluate(val);
      } else {
        return val;
      }
    };
  }
]);
angular.module("iso.directives", ["iso.config", "iso.services", "iso.controllers"]);

angular.module("iso.directives")
.directive("isotopeContainer", ["$injector", "$parse", function($injector, $parse) {
    "use strict";
    var options;
    options = {};
    return {
      controller: "angularIsotopeController",
      link: function(scope, element, attrs) {
        var isoInit, isoOptions, linkOptions;
        linkOptions = [];
        isoOptions = attrs.isoOptions;
        isoInit = {};
        if (isoOptions) {
          linkOptions = $parse(isoOptions)(scope);
          if (angular.isObject(linkOptions)) {
            scope.updateOptions(linkOptions);
          }
        }
        isoInit.element = element;
        isoInit.isoOptionsEvent = attrs.isoOptionsSubscribe;
        isoInit.isoMethodEvent = attrs.isoMethodSubscribe;
        isoInit.isoMode = attrs.isoMode;
        if (attrs.isoIgnore !== "true") {
          scope.init(isoInit);
        }
        return element;
      }
    };
  }
])
.directive("isotopeItem", [
  "$rootScope", "iso.config", "iso.topics", "$timeout", function($rootScope, config, topics, $timeout) {
    return {
      restrict: "A",
      require: "^isotopeContainer",
      link: function(scope, element, attrs) {

        scope.setIsoElement(element);
        scope.$on('$destroy', function(message) {
          $rootScope.$broadcast(topics.MSG_REMOVE, element);
        });
        if (attrs.ngRepeat && true === scope.$last && "addItems" === scope.isoMode) {
          element.ready(function() {
            return $timeout((function() {
              return scope.refreshIso();
            }), config.refreshDelay || 0);
          });
        }
        return element;
      }
    };
  }
])
.directive("isoSortbyData", function() {
    return {
      restrict: "A",
      controller: "isoSortByDataController",
      link: function(scope, element, attrs) {
        var methSet, methods, optEvent, optKey, optionSet, options;
        optionSet = $(element);
        optKey = optionSet.attr("ok-key");
        optEvent = "iso-opts";
        options = {};
        methSet = optionSet.find("[ok-sel]");
        methSet.each(function(index) {
          var $this;
          $this = $(this);
          return $this.attr("ok-sortby-key", scope.getHash($this.attr("ok-sel")));
        });
        methods = scope.createSortByDataMethods(methSet);
        return scope.storeMethods(methods);
      }
    };
  }
)
.directive("optKind", ['optionsStore', function(optionsStore) {
  return {
    restrict: "A",
    controller: "isoSortByDataController",
    link: function(scope, element, attrs) {
      var createSortByDataMethods, createOptions, doOption, emitOption, optKey, optPublish, methPublish, optionSet, determineAciveClass, activeClass, activeSelector, active;
      optionSet = $(element);
      optPublish = attrs.okPublish || topics.MSG_OPT;
      methPublish = attrs.okPublish || topics.MSG_METH;
      optKey = optionSet.attr("ok-key");

      determineActiveClass = function() {
        activeClass = attrs.okActiveClass;
        if (!activeClass) {
          activeClass = optionSet.find(".selected").length ? "selected" : "active";
        }
        activeSelector = "." + activeClass;
        active = optionSet.find(activeSelector);
      };

      createSortByDataMethods = function(optionSet) {
        var methSet, methods, optKey, options;
        optKey = optionSet.attr("ok-key");
        if (optKey !== "sortBy") {
          return;
        }
        options = {};
        methSet = optionSet.find("[ok-sel]");
        methSet.each(function(index) {
          var $this;
          $this = $(this);
          return $this.attr("ok-sortby-key", scope.getHash($this.attr("ok-sel")));
        });
        methods = scope.createSortByDataMethods(methSet);
        return scope.storeMethods(methods);
      };

      createOptions = function(item) {
        var ascAttr, key, option, virtualSortByKey;
        if (item) {
          option = {};
          virtualSortByKey = item.attr("ok-sortby-key");
          ascAttr = item.attr("opt-ascending");
          key = virtualSortByKey || item.attr("ok-sel");
          if (virtualSortByKey) {
            option.sortAscending = (ascAttr ? ascAttr === "true" : true);
          }
          option[optKey] = key;
          return option;
        }
      };

      emitOption = function(option) {
        optionsStore.store(option);
        return scope.$emit(optPublish, option);
      };

      doOption = function(event) {
        var selItem;
        event.preventDefault();
        selItem = $(event.target);
        if (selItem.hasClass(activeClass)) {
          return false;
        }
        optionSet.find(activeSelector).removeClass(activeClass);
        selItem.addClass(activeClass);
        emitOption(createOptions(selItem));
        return false;
      };

      determineActiveClass();

      createSortByDataMethods(optionSet);

      if (active.length) {
        var opts = createOptions(active);
        optionsStore.store(opts);
      }

      return optionSet.on("click", function(event) {
        return doOption(event);
      });
    }
  };
}]);angular.module("iso.services", ["iso.config"], [
  '$provide', function($provide) {
    return $provide.factory("optionsStore", [
      "iso.config", function(config) {
        "use strict";
        var storedOptions;
        storedOptions = config.defaultOptions || {};
        return {
          store: function(option) {
            storedOptions = $.extend.apply(null, [true, storedOptions].concat(option));
            return storedOptions;
          },
          retrieve: function() {
            return storedOptions;
          }
        };
      }
    ]);
  }
])
.value('iso.topics', {
  MSG_OPT:'ng_iso_msgopt',
  MSG_METH:'ng_iso_msgmet',
  MSG_REMOVE:'ng_iso_remel'
});
})(window, document);

/* **********************************************
     Begin twitwall.ng.js
********************************************** */

var twitter_json_search = wpData.themeRoot + "/ng.socialwall/twitter/search.php";
var flickr_json_search = wpData.themeRoot + "/ng.socialwall/flickr/search.php";

var app = angular.module('socialwallApp', ['relativeDate', 'ngAnimate']);
var searchterm = "%23gcmuc";


app.controller("appController", function($scope, $http, $interval){
	$scope.currentTime = 0;
	$scope.searchterm = decodeURIComponent(searchterm);

	$scope.init = function(){
		$interval(function(){
			$scope.getCurrentTime();
		}, 1000);
	}

	$scope.requestFullscreen = function(){
		$("body").requestFullScreen();
	}

	$scope.getCurrentTime = function(){
		$scope.currentTime = new Date();
	}

});

app.controller("socialwallController", function($scope, $http, $interval){
	$scope.shownItems = [];
	$scope.socialContent = [];
	$scope.max_id_str = 0;
	$scope.socialWall = null;

	$scope.init = function(){

		$scope.socialWall = $("#social_wall");

		var opts = {
			itemSelector: ".social_wall_item",
			masonry: {
				columnWidth: ".twitter",
			},
		};
		$scope.socialWall.isotope(opts);

		$scope.loadContent();
		$scope.runner = $interval(function(){
			$scope.loadContent();
		}, 10000)


		$scope.$watchCollection("socialContent", function(newValue, oldValue){
			setTimeout(function(){
				//$scope.socialWall.isotope('destroy');
				$scope.socialWall.isotope('reloadItems').isotope(opts);
			}, 0);
		});
	}

	$scope.loadContent = function(){
		$scope.loadTwitter();
		$scope.loadFlickr();
	};

	// Load stuff from twitter
	$scope.loadTwitter = function(){

		var httpUrl = twitter_json_search + "?callback=JSON_CALLBACK";
		var config = {
			params: {
				q: searchterm,
			},
		};

		if($scope.shownItems.length > 0 && $scope.max_id_str != 0){
			config.params.since_id = $scope.max_id_str
		}

		$http.jsonp(httpUrl, config).success(function(data){
			$scope.max_id_str = data.search_metadata.max_id_str;

			for(i in data.statuses){
				var t = data.statuses[i];

				var tmp_image = null;

				if(typeof(t.entities.media) != "undefined"){
					tmp_image = t.entities.media[0].media_url;
				}

				$scope.addSocialContent({
					id: t.id_str,
					user_name: "@" + t.user.screen_name,
					display_name: t.user.name,
					user_image: t.user.profile_image_url,
					image: tmp_image,
					time: Date.parse(t.created_at),
					text: t.text,
					type: "twitter",
				})
			}
		});
	};

	// Load stuff from flickr
	$scope.loadFlickr = function(){

		var httpUrl = flickr_json_search + "?callback=JSON_CALLBACK";
		var config = {
			params: {
				q: searchterm.replace("%23", ""),
			},
		};

		$http.jsonp(httpUrl, config).success(function(data){
			if(data.stat == "fail"){
				return false;
			};
			for(i in data.photos.photo){
				var p = data.photos.photo[i];

				$scope.addSocialContent({
					id: p.id,
					user_name: null,
					display_name: p.ownername,
					user_image: null,
					image: p.url_l,
					time: p.dateupload*1000,
					text: null,
					type: "flickr",
				})
			}
		});
	};


	$scope.addSocialContent = function(obj){
		var item = {
			id: obj.id,
			user_name: obj.user_name,
			display_name: obj.display_name,
			user_image: obj.user_image,
			image: obj.image,
			time: obj.time,
			type: obj.type,
			text: obj.text,
		}

		if($scope.shownItems.indexOf(item.type+"_"+item.id) == -1){
			$scope.socialContent.unshift(item);
			$scope.shownItems.unshift(item.type+"_"+item.id);
		}
	};
});


app.controller("socialItemCtrl", function($scope, $http, $interval){
	$scope.thisItem = {};
	$scope.thisItem.textHidden = false;
	$scope.baseInterval = 30000;

	$scope.itemInit = function(){
		$scope.thisItem = $scope.$parent.item;

		var tick = $scope.baseInterval * Math.random() + $scope.baseInterval;

		if($scope.thisItem.text != null && $scope.thisItem.image != null){
			$interval(function(){
				$scope.toggleImage();
			}, tick);
		}
	}

	$scope.toggleImage = function(){
		$scope.thisItem.textHidden = !$scope.thisItem.textHidden;
	}
});


(function() {
    var
        fullScreenApi = {
            supportsFullScreen: false,
            isFullScreen: function() { return false; },
            requestFullScreen: function() {},
            cancelFullScreen: function() {},
            fullScreenEventName: '',
            prefix: ''
        },
        browserPrefixes = 'webkit moz o ms khtml'.split(' ');

    // check for native support
    if (typeof document.cancelFullScreen != 'undefined') {
        fullScreenApi.supportsFullScreen = true;
    } else {
        // check for fullscreen support by vendor prefix
        for (var i = 0, il = browserPrefixes.length; i < il; i++ ) {
            fullScreenApi.prefix = browserPrefixes[i];

            if (typeof document[fullScreenApi.prefix + 'CancelFullScreen' ] != 'undefined' ) {
                fullScreenApi.supportsFullScreen = true;

                break;
            }
        }
    }

    // update methods to do something useful
    if (fullScreenApi.supportsFullScreen) {
        fullScreenApi.fullScreenEventName = fullScreenApi.prefix + 'fullscreenchange';

        fullScreenApi.isFullScreen = function() {
            switch (this.prefix) {
                case '':
                    return document.fullScreen;
                case 'webkit':
                    return document.webkitIsFullScreen;
                default:
                    return document[this.prefix + 'FullScreen'];
            }
        }
        fullScreenApi.requestFullScreen = function(el) {
            return (this.prefix === '') ? el.requestFullScreen() : el[this.prefix + 'RequestFullScreen']();
        }
        fullScreenApi.cancelFullScreen = function(el) {
            return (this.prefix === '') ? document.cancelFullScreen() : document[this.prefix + 'CancelFullScreen']();
        }
    }

    // jQuery plugin
    if (typeof jQuery != 'undefined') {
        jQuery.fn.requestFullScreen = function() {

            return this.each(function() {
                if (fullScreenApi.supportsFullScreen) {
                    fullScreenApi.requestFullScreen(this);
                }
            });
        };
    }

    // export api
    window.fullScreenApi = fullScreenApi;
})();